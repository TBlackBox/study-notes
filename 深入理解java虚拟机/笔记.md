
# 1.java 虚拟机定义
虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

java虚拟机（JVM）可以以一次一条指令的方式来解释字节码（把它映射到实际的处理器指令），或者字节码也可以由实际处理器中称作just-in-time的编译器进行进一步的编译


# 自动内存管理

## 运行时数据区域





# 垃圾收集（GC）

1.程序计数器,虚拟机栈,本地方法栈  随着线程而生，随着线程而灭，不需要过多的考虑垃圾回收问题

 垃圾回器关注的部分就是 推和方法区



## 对象是否存活（确实是否需要回收）

### 应用计数算法
给对象添加一个引用计数器，引用的时候加1，引用失效时减1，为0时  就是不能再引用的 。虚拟机没有采用这个，解决不了循环引用的问题。  即  a = b,b = a,计数器一直不为0.



### 可达性分析算法
GC Roots 出发   当对象没有任何引用链（就是对象不可达），对象和 GC Roots  不能连成一根线，就被判断为可回收对象。



### finalize()
* Object 提供的一个方法  可以被覆盖  覆盖了只有要经历2个GC 的周期才能被清除
* 覆盖这个方法可以用来做资源释放和数据清理 单不能保证一定执行保证调用finalize支持user-isible同步锁

注意：尽量可以避免使用它（甚至可以忘记），try-finally或者其他方式能做到更好，更及时


## 垃圾收集算法

1. 标记-清除算法
对需要回收的对象做标记，统一进行回收
是基本算法    缺点  效率低  空间碎片多

2. 复制算法
内存分两部分  一半用用完了  把村和存活的复制到另一半   在移除行回收用完这一半

现在商业虚拟机采用这种算法来回收新生代

3. 标记整理算法
让所存活的都像一段移动  然后清理调标记以外的内存

4. 分代收集算法（当前商业虚拟机采用的）
将java 推分成新生代和老年代   根据各特定采用不同的算法

    新生代   对象村和率低  用复制耍法
    老年代   对象存活率高  没有额外空点担保   用  标记-清理  或  标记-整理


## HotSpot 算法实现

## 枚举跟节点

可达行分析  这个工作必须确保在一致性快照中进行，不然准确性无法保证，必须停掉java 执行的所有线程，会停顿下来

## 安全点(sefepoint)
要让线程中断  需要在线程设置几个点  这些点就是安全点   例如方法跳转 循环跳转  异常跳转

    线程执行的时候可以才能判断安全点 进入GC 没有执行的线程就不能晓得线程到不到安全点  用安全区域解决

## 安全区域（sefe Region）
一段代码  引用关系不会变化  任何地方地址GC 都是安全的   看着是sefepoint 的扩展


## HotSpot 的垃圾收集器

### serial收集器
单线程收集器  工作是会暂停所有的工作线程  Cliet模式下默认的新生代收集器  在收集一两百M的内存下 控制在几十豪秒到100多毫秒  不频繁是能接受的

### parNew 收集器

是Serial的 多线程版本  包括Serial 可用的所有控制参数 适合Server 模式下首选新生代收集器  目前只有他能和CMS收集器配合工作
在单CPU下性能可能达不到Serial  默认开启和cpu核心一样多 的线程  同样需要暂停工作线程

### parallel Scavenge收集器
新生代收集器  并行多线程  关注的是吐吐量  可以开启自适应调节策略是和ParNew 的一个重要区别


### Serial Old 收集器
Serial收集器的老年代版本，单线程  用的标记-整理  算法  Client模式下使用  
如果在Server下使用，有两大用途：
+ JDK1.5之前版本与Parallel Scavenge 收集器搭配使用
+ 作为CMS收集器的后备方案 在并发收集发生 Concurrent Mode Failure时使用

### Parallel Old  收集器
是Parallel Scavenge 收集器老年代版本 使用标记-整理  算法  JDK1.6后出现

Parallel Scavenge 比较尴尬  新生代使用它 老年代就必须使用 Serial Old,  单Serial old 在服务端是拖累

parallel Old 解决了尴尬

在吞吐量敏感的场合，有限考虑
parallel Scavenge 和 parallel Old


### CMS收集器
已获得最短停顿时间得收集器，网站和B/S 上重视响应速度，比较符合这一类需求

标记-清除算法实现
优点：
并收集  低停顿
缺点：
* cpu资源非常敏感，默认开启回收线程数量是（cpu数量+3）/4
* 不能处理浮动垃圾（浮动垃圾：就是在收集的时候，工作线程产生的垃圾） 
 JDK1.5后  老年代使用了68% 启动cms,JDK1.6  92%

 预留内存无法满足时  启动Serial Old  重新收集
 * 导致碎片问题  分大对象是 触发 FULL GC  默认 开启了进行FULL GC时进行碎片清理 

### G1收集器
当今收集器最前沿的成果之一
面向服务端
特点：
* 并行与并发
* 分代收集
* 空间整合
* 可预测停顿


# 内存分配与回收策略

1. 对象优先分配到Eden 区
2. 大对象直接进入老年代
大对象指很长字符串及数组，写程序时要避免朝生夕灭的短命大对象    还有内存  都 容易触发GC
3. 长期村和的对象将进入老年代
 对象有个年龄计数器 在Ende 出现一个Minor Gc  存活 并且Survivor 能存下  计数器加1
 对象在Survivor 里熬过一次Minor GC 增加1岁 增加到一定程度 就到老年代 默认是是15，通过 -XX:+PrintTenuringDistribution设置
4. 动态对象年龄判断
同年龄对象之和大于Survior的一半 ，大于等于它的对象都会进入老年代，年龄阀值都不起作用了
5. 空间分配担保


## 新生代GC(Minor)
指新生代垃圾收集动作，Java对象大多具备朝生夕灭的特性，Minor Gc 非常频繁，但也非常快

## 老年代GC(Major GC/Full Gc)
指发生在老年代的GC,出现Major Gc ,经常会伴随至少一次的Minor GC(不决对  parrallel Scavenge 收集策略都直接进行Majjor GC)



# 实战

1. 并不是变好  ，堆内存加大就可以提升性能  增加了FULL GC 时间  应用会明显卡顿  ，可以用集群 部署多台应用的形式  ，减少卡顿  64 消耗内存要比 32位消耗大  指针膨胀

2. 集群同步导致内存溢出
网络条件不好的情况下  使用统一缓存  写 导致在内存中堆积（网不好）

3. 对外内存溢出
堆分的内存太大  导致堆外内存溢出

4. 外部命令导致系统缓慢

5. 服务器jvm进程崩溃
大量的请求 长时间不返回  超过了jvm的承受能力

6. 不恰当的数据结构导致内存占用过大

7. 由windows虚拟内存导致长时间卡顿



# Java内存模型与线程
(TransactionsPer Second,TPS)没秒事务处理数，是衡量一个服务器性能的高低好坏。他代表一秒雷服务器平均能响应的请求总数。

