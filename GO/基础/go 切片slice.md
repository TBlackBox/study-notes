# 简介

slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。



### 切片的结构体

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```



## 数组和切片

1. C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据
2. 切片有底层数组。
3. 切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。



## 创建切片的两种方式

1. 通过字面量形式

   ```go
   //声明切片
   var s1 = []int{0，1，2，3}
   var s = s1[:]
   ```

2. 通过make创建切片

   ```go
   var slice []type = make([]type, len)
   slice  := make([]type, len)
   slice  := make([]type, len, cap)
   ```

   使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作

####  nil和空切片

nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。

空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。

空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。

```go
//nil 切片
var slice []int


//空切片
silce := make( []int , 0 )
slice := []int{ }
```



最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。

## 获取切片长度和容量

- len(切片)
- cap(切片)

容量分配都是原来的两倍



## 切片的拷贝

```go
copy(切片1，切片2)
```

函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。



## 切片遍历

```go
data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
slice := data[:]
for index, value := range slice {
    fmt.Printf("inde : %v , value : %v\n", index, value)
}
```

**注意：**如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝，不是引用传递。vlaue 的地址都不变，故直接改变value值，原切片的值不能改变，如果要改变的话，&slice[index] 获取真实的地址获取真实地址改变。

## 字符串切片

string本身是不可变的，因此要改变string中字符。需要转换

```go
str := "Hello world"
s := []byte(str) //中文字符需要用[]rune(str)
```



## 扩容

1. 扩容策略

   容量小于1024个原素，扩容后增加一倍的容量。

   容量大于1024个元素，扩容因子就变为了1.25，即增加原来容量的四分之一。



3. 生成新数组还是老数组

   不一定

   - 可能是老数组

     如果是字面量创建切片时，cap不等于指向数组的总容量，就有可能是老数组。如果是数组的话，多个切片间容易出问题。

   - 产生新数组

     原来数组容量不够，会新开一个内区域，把 原来的拷贝过去，这样新的和原来的数组相互不影响。尽量避免老数组的情况。