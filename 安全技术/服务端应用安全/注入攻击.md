# 简介
注入攻击是web安全中最为常见的攻击方式，XSS本质上也是一种HTML的注入攻击。

# 注入攻击有两个条件
1. 用户能够控制数据的输入；
2. 代码拼凑了用户输入的数据，把数据当做代码执行。


# 注入攻击类型
## SQL注入
例如：
```sql
sql = "select * from OrdersTable where ShipCity='"+ShipCity+"'"
```
其中ShipCity是用户输入的内容，如果用户输入为
```
Beijing'; drop table OrdersTable--，
```
那么实际执行的SQL语句为
```sql
select * from OrdersTable where ShipCIty='Beijing'; drop table OrdersTable--'（--为单行注释）
```
如果web服务器开启了错误回显，会为攻击者提供极大的便利，从错误回显中获取敏感信息。

还有就是恶意查询语句注入

## 盲注
盲注的高级技巧，根据函数事件长短的变化，判断注入语句是否执行成功。
构建简单的条件语句，根据访问页面是否发生变化来判断SQL是否执行成功。
例如：
2011年TinKode入侵mysql.com，漏洞出现在
```
http://mysql.com/customers/view/index.html?id=1170
```
利用mysql中的benchmark函数，让同一个函数执行若干次，使得结果返回的比平时要长。构造的攻击参数为1170 
```sql
union select if(substring(current,1,1)=char(119), benchmark(500000,encode('msg','by 5 seconds')),null) from (select database() as current) as tbl;
```
这段语句是判断数据库名第一个字母是否为w。如果判断为真，返回延时较长。攻击者遍历所有字母，直到将整个数据库名全部验证为止。

## Timiing Attack
在Mysql中有一个BENCHMMARK()可以让同一个函数执行若干次，通过检查函数结果返回时间长短的变换来判断出注入语句是否执行成功。
```sql
BENCHMARK(count,expr);
```
表示expr表达式执行count次。

# 数据库攻击
## SQL注入

### 防御sql注入
1. 使用预编译的语句，绑定变量（参数化），不要使用拼接的形式拼接sql语句。
2. 使用存储过程（不推荐使用存储过程，不利于维护）。
3. 检查数据类型（必须按照严格的参数类型来匹配）。
4. 使用安全函数（充分各种Web语言提供的编码函数对抗SQL注入）
5. 使用最小权限(避免web用户直接使用root,dbwner等高权限账户链接db).

## 命令执行
利用“用户自定义函数”即UDF来执行命令。


## 攻击存储过程
利用存储过程执行系统函数

## 编码问题
通过编码问题来工具，要尽量统一数据库，操作系统，web应用程序使用的字符集。

# 其他注入
## XML注入
通过拼接的形式拼接xml,导致xml数据结构和原本的发生变化。

## 防止方法
对用户输入数据中包含的“语言本身的保留字符”进行转义。

## 代码注入
代码注入往往是由一些不安全的函数或方法引起的，常见于脚本语言，最典型的的代表是`eval()`。
对抗代码注入，需要禁用`eval()`等可以执行的函数，如果一定要使用，就要对用户输入的数据进行处理。

*** 注意：主要还是根据脚本语言的文档，把禁用的函数给禁用了***


## CRLF注入
CR指\r，LF指\n，这两个字符用于换行，被用作不同语义之间的分隔符，因此通过CRLF字符注入，可以改变原有的语义。  

例如，HTTP头是通过\r\n来分割的，在HTTP头中注入两次\r\n，后面跟着的是HTTP Body，可以构造恶意脚本从而得以执行。
CRLF防御方案非常简单，只需要处理好\r、\n两个字符就好。


# 总结
攻击者能够成功的注入的话，主要原因就是代码和数据没有分离导致的，解决方案就是将代码和数据分离，如果分离不出来，就要在拼凑的地方进行安全检查等等。



