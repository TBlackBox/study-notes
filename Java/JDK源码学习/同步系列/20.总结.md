# 简介

同步系列到此就结束了，本篇文章对同步系列做一个总结。

## 脑图

下面是关于同步系列的一份脑图，列举了主要的知识点和问题点，看过本系列文章的可以根据脑图自行回顾所学的内容，也可以作为面试前的准备。

![图片](../../../sources\img\wrwqddsdss.png)

## 总结

所谓同步，就是保证多线程（包括多进程）对共享资源的读写能够安全有效的运行。

根据同步的运用场景的不同，实现同步的方式也是随之一起变化，但是总结下来，这些实现方式之间又有一些共通之处。

不管是互斥锁、读写锁、信号量、CountDownLatch、回环栅栏、Phaser，还是各种分布式锁，它们都是基于对同一个共享变量（状态变量）的控制，以达到同步的目的。

互斥锁，state为大于等于1（可重入）表示已加锁，state为0表示未加锁；

读写锁，state的高16位存储读的次数【本篇文章由公众号“彤哥读源码”原创】，低16位存储写的次数；

信号量，state存储许可的次数，被使用一次许可减一，被释放一次许可加一；

CountDownLatch，state存储初始次数，countDown()次数减一，当次数减为0的时候await()被激活；

回环栅栏，基于ReentrantLock实现，相当于在CountDownLatch的基础上加了“代”的概念，保证可重复使用；

Phaser，state的高32位存储当前阶段phase，中16位存储当前阶段参与者（任务）的数量parties，低16位存储未完成参与者的数量unarrived，每个阶段的参与者都可以控制，相对于回环栅栏更灵活；

mysql分布式锁，基于数据库的getlock()/releaselock()对共享变量进行控制；

zookeeper分布式锁，基于有序临时节点对共享变量进行控制；

redis分布式锁，基于内存键值对对共享变量进行控制；

总结下来，所有同步器的关键因素只有一个——共享变量，只要能够对共享变量进行精确的控制，就能实现同步，以后出现新的组件我们一样可以根据这条原理使用新的组件来实现分布式同步器。