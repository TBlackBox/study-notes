# 简介

大端和小端的名字来源与《格利佛游记》，鸡蛋的大的一端和小的一端。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。



# 什么是大端和小端

举一个例子，比如数字0x12 34 56 78在内存中的表示形式。

**1)大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。**

　　　　　　　　　　　　**（其实大端模式才是我们直观上认为的模式，和字符串存储的模式差类似）**

```
低地址 --------------------> 高地址
0x12  |  0x34  |  0x56  |  0x78
```

**2)小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。**

```
低地址 --------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12
```

**3)下面是两个具体例子：** 

16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| **内存地址** | **小端模式存放内容** | **大端模式存放内容** |
| ------------ | -------------------- | -------------------- |
| **0x4000**   | **0x34**             | **0x12**             |
| **0x4001**   | **0x12**             | **0x34**             |

32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| **内存地址** | **小端模式存放内容** | **大端模式存放内容** |
| ------------ | -------------------- | -------------------- |
| **0x4000**   | **0x78**             | **0x12**             |
| **0x4001**   | **0x56**             | **0x34**             |
| **0x4002**   | **0x34**             | **0x56**             |
| **0x4003**   | **0x12**             | **0x78 **            |

 

 **4)大端小端没有谁优谁劣，各自优势便是对方劣势：**

小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
大端模式 ：符号位的判定固定为第一个字节，容易判断正负。



# 数组在大端小端情况下的存储：

　　以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：
　　Big-Endian: 低地址存放高位，如下：

```
高地址
    \---------------
    buf[3] (0x78) -- 低位
    buf[2] (0x56)
    buf[1] (0x34)
    buf[0] (0x12) -- 高位
    \---------------
低地址
```

Little-Endian: 低地址存放低位，如下：

```
高地址
    \---------------
    buf[3] (0x12) -- 高位
    buf[2] (0x34)
    buf[1] (0x56)
    buf[0] (0x78) -- 低位
    \--------------
低地址
```

# 为什么会有大小端模式之分呢？

   这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了**大端存储模式和小端存储模式**。

例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

# 如何判断机器的字节序

可以编写一个小的测试程序来判断机器的字节序：

```c
BOOL IsBigEndian()  
{  
    int a = 0x1234;  
    char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分  
    if( b == 0x12)  
    {  
        return TRUE;  
    }  
    return FALSE;  
}
```

联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：

```c
BOOL IsBigEndian()  
{  
    union NUM  
    {  
        int a;  
        char b;  
    }num;  
    num.a = 0x1234;  
    if( num.b == 0x12 )  
    {  
        return TRUE;  
    }  
    return FALSE;  
}
```

# 六、常见的字节序

一般操作系统都是小端，而通讯协议是大端的。

###### 4.1 常见CPU的字节序

Big Endian : PowerPC、IBM、Sun
Little Endian : x86、DEC
ARM既可以工作在大端模式，也可以工作在小端模式。

###### 4.2 常见文件的字节序

Adobe PS – Big Endian
BMP – Little Endian
DXF(AutoCAD) – Variable
GIF – Little Endian
JPEG – Big Endian
MacPaint – Big Endian
RTF – Little Endian

另外，Java和所有的网络通讯协议都是使用Big-Endian的编码。

# 如何进行转换

对于字数据（16位）：（程序中的“\”表示当前行和下一行是同一行）

```
#define BigtoLittle16(A)   (( ((uint16)(A) & 0xff00) >> 8)    | \  
                                       (( (uint16)(A) & 0x00ff) << 8))  
```

对于双字数据（32位）：

```
#define BigtoLittle32(A)   ((( (uint32)(A) & 0xff000000) >> 24) | \  
                                       (( (uint32)(A) & 0x00ff0000) >> 8)   | \  
                                       (( (uint32)(A) & 0x0000ff00) << 8)   | \  
                                       (( (uint32)(A) & 0x000000ff) << 24))  
```

# 八、从软件的角度理解端模式

​    从软件的角度上，不同端模式的处理器进行数据传递时必须要考虑端模式的不同。如进行网络数据传递时，必须要考虑端模式的转换。在Socket接口编程中，以下几个函数用于大小端字节序的转换。

```
#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  
```

其中互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同，如PowerPC处理器使用大端模式，而Pentuim处理器使用小端模式。
    大端模式处理器的字节序到网络字节序不需要转换，此时ntohs(n)=n，ntohl = n；而小端模式处理器的字节序到网络字节必须要进行转换，此时ntohs(n) = __swab16(n)，ntohl = __swab32(n)。__swab16与__swab32函数定义如下所示。

```c
#define ___swab16(x)  
{  
            __u16 __x = (x);  
            ((__u16)(  
                        (((__u16)(__x) & (__u16)0x00ffU) << 8) |  
                        (((__u16)(__x) & (__u16)0xff00U) >> 8) ));  
}  
  
  
#define ___swab32(x)  
{  
            __u32 __x = (x);  
            ((__u32)(  
                        (((__u32)(__x) & (__u32)0x000000ffUL) << 24) |  
                        (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) |  
                        (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) |  
                        (((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));  
}  
```

 PowerPC处理器提供了lwbrx，lhbrx，stwbrx，sthbrx四条指令用于处理字节序的转换以优化__swab16和__swap32这类函数。此外PowerPC处理器中的rlwimi指令也可以用来实现__swab16和__swap32这类函数。

​    在对普通文件进行处理也需要考虑端模式问题。在大端模式的处理器下对文件的32，16位读写操作所得到的结果与小端模式的处理器不同。单纯从软件的角度理解上远远不能真正理解大小端模式的区别。事实上，真正的理解大小端模式的区别，必须要从系统的角度，从指令集，寄存器和数据总线上深入理解，大小端模式的区别。

 

# 九、从系统的角度理解端模式

先补充两个关键词，MSB和LSB：
- MSB:MoST Significant Bit ------- 最高有效位
- LSB:Least Significant Bit ------- 最低有效位

 

​    处理器在硬件上由于端模式问题在设计中有所不同。从系统的角度上看，端模式问题对软件和硬件的设计带来了不同的影响，当一个处理器系统中大小端模式同时存在时，必须要对这些不同端模式的访问进行特殊的处理。
​    PowerPC处理器主导网络市场，可以说绝大多数的通信设备都使用PowerPC处理器进行协议处理和其他控制信息的处理，这也可能也是在网络上的绝大多数协议都采用大端编址方式的原因。因此在有关网络协议的软件设计中，使用小端方式的处理器需要在软件中处理端模式的转变。而Pentium主导个人机市场，因此多数用于个人机的外设都采用小端模式，包括一些在网络设备中使用的PCI总线，Flash等设备，这也要求在硬件设计中注意端模式的转换。
​    本文提到的小端外设是指这种外设中的寄存器以小端方式进行存储，如PCI设备的配置空间，NOR FLASH中的寄存器等等。对于有些设备，如DDR颗粒，没有以小端方式存储的寄存器，因此从逻辑上讲并不需要对端模式进行转换。在设计中，只需要将双方数据总线进行一一对应的互连，而不需要进行数据总线的转换。
​    如果从实际应用的角度说，采用小端模式的处理器需要在软件中处理端模式的转换，因为采用小端模式的处理器在与小端外设互连时，不需要任何转换。而采用大端模式的处理器需要在硬件设计时处理端模式的转换。大端模式处理器需要在寄存器，指令集，数据总线及数据总线与小端外设的连接等等多个方面进行处理，以解决与小端外设连接时的端模式转换问题。在寄存器和数据总线的位序定义上，基于大小端模式的处理器有所不同。
​    一个采用大端模式的32位处理器，如基于E500内核的MPC8541，将其寄存器的最高位msb（most significant bit）定义为0，最低位lsb（lease significant bit）定义为31；而小端模式的32位处理器，将其寄存器的最高位定义为31，低位地址定义为0。与此向对应，采用大端模式的32位处理器数据总线的最高位为0，最高位为31；采用小端模式的32位处理器的数据总线的最高位为31，最低位为0。     
​    大小端模式处理器外部总线的位序也遵循着同样的规律，根据所采用的数据总线是32位，16位和8位，大小端处理器外部总线的位序有所不同。大端模式下32位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第31位，LSB是第24~31字段。小端模式下32位总线的msb是第31位，MSB是数据总线的第31~24位，lsb是第0位，LSB是7~0字段。大端模式下16位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第15位，LSB是第8~15字段。小端模式下16位总线的msb是第15位，MSB是数据总线的第15~7位，lsb是第0位，LSB是7~0字段。大端模式下8位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第7位，LSB是第0~7字段。小端模式下8位总线的msb是第7位，MSB是数据总线的第7~0位，lsb是第0位，LSB是7~0字段。
​     由上分析，我们可以得知对于8位，16位和32位宽度的数据总线，采用大端模式时数据总线的msb和MSB的位置都不会发生变化，而采用小端模式时数据总线的lsb和LSB位置也不会发生变化。
​     为此，大端模式的处理器对8位，16位和32位的内存访问（包括外设的访问）一般都包含第0~7字段，即MSB。小端模式的处理器对8位，16位和32位的内存访问都包含第7~0位，小端方式的第7~0字段，即LSB。由于大小端处理器的数据总线其8位，16位和32位宽度的数据总线的定义不同，因此需要分别进行讨论在系统级别上如何处理端模式转换。在一个大端处理器系统中，需要处理大端处理器对小端外设的访问。

# 十、实际中的例子

​    虽然很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。这里，举一个MODBUS通讯的例子。在MODBUS中，数据需要组织成数据报文，该报文中的数据都是大端模式，即低地址存高位，高地址存低位。假设有一16位缓冲区m_RegMW[256]，因为是在x86平台上，所以内存中的数据为小端模式：m_RegMW[0].low、m_RegMW[0].high、m_RegMW[1].low、m_RegMW[1].high……
为了方便讨论，假设m_RegMW[0] = 0x3456; 在内存中为0x56、0x34。
​    现要将该数据发出，如果不进行数据转换直接发送，此时发送的数据为0x56,0x34。而Modbus是大端的，会将该数据解释为0x5634而非原数据0x3456，此时就会发生灾难性的错误。所以，在此之前，需要将小端数据转换成大端的，即进行高字节和低字节的交换，此时可以调用步骤五中的函数BigtoLittle16(m_RegMW[0])，之后再进行发送才可以得到正确的数据。

